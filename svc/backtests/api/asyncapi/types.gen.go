// Package "asyncapi" provides primitives to interact with the AsyncAPI specification.
//
// Code generated by github.com/lerenn/asyncapi-codegen version v0.30.2 DO NOT EDIT.
package asyncapi

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/lerenn/asyncapi-codegen/pkg/extensions"

	"github.com/google/uuid"
)

// AsyncAPIVersion is the version of the used AsyncAPI document
const AsyncAPIVersion = "1.0.0"

// controller is the controller that will be used to communicate with the broker
// It will be used internally by AppController and UserController
type controller struct {
	// broker is the broker controller that will be used to communicate
	broker extensions.BrokerController
	// subscriptions is a map of all subscriptions
	subscriptions map[string]extensions.BrokerChannelSubscription
	// logger is the logger that will be usedÂ² to log operations on controller
	logger extensions.Logger
	// middlewares are the middlewares that will be executed when sending or
	// receiving messages
	middlewares []extensions.Middleware
}

// ControllerOption is the type of the options that can be passed
// when creating a new Controller
type ControllerOption func(controller *controller)

// WithLogger attaches a logger to the controller
func WithLogger(logger extensions.Logger) ControllerOption {
	return func(controller *controller) {
		controller.logger = logger
	}
}

// WithMiddlewares attaches middlewares that will be executed when sending or receiving messages
func WithMiddlewares(middlewares ...extensions.Middleware) ControllerOption {
	return func(controller *controller) {
		controller.middlewares = middlewares
	}
}

type MessageWithCorrelationID interface {
	CorrelationID() string
	SetCorrelationID(id string)
}

type Error struct {
	Channel string
	Err     error
}

func (e *Error) Error() string {
	return fmt.Sprintf("channel %q: err %v", e.Channel, e.Err)
}

// CryptellationBacktestsEventsParameters represents CryptellationBacktestsEventsId channel parameters
type CryptellationBacktestsEventsParameters struct {
	// Description: Backtest identifier
	Id int64
}

// AdvanceBacktestRequestMessage is the message expected for 'AdvanceBacktestRequest' channel
type AdvanceBacktestRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		Id BacktestIDSchema `json:"id"`
	}
}

func NewAdvanceBacktestRequestMessage() AdvanceBacktestRequestMessage {
	var msg AdvanceBacktestRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newAdvanceBacktestRequestMessageFromBrokerMessage will fill a new AdvanceBacktestRequestMessage with data from generic broker message
func newAdvanceBacktestRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (AdvanceBacktestRequestMessage, error) {
	var msg AdvanceBacktestRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AdvanceBacktestRequestMessage data
func (msg AdvanceBacktestRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg AdvanceBacktestRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *AdvanceBacktestRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *AdvanceBacktestRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// AdvanceBacktestResponseMessage is the message expected for 'AdvanceBacktestResponse' channel
type AdvanceBacktestResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewAdvanceBacktestResponseMessage() AdvanceBacktestResponseMessage {
	var msg AdvanceBacktestResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newAdvanceBacktestResponseMessageFromBrokerMessage will fill a new AdvanceBacktestResponseMessage with data from generic broker message
func newAdvanceBacktestResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (AdvanceBacktestResponseMessage, error) {
	var msg AdvanceBacktestResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AdvanceBacktestResponseMessage data
func (msg AdvanceBacktestResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg AdvanceBacktestResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *AdvanceBacktestResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *AdvanceBacktestResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// BacktestsEventMessage is the message expected for 'BacktestsEvent' channel
type BacktestsEventMessage struct {
	// Payload will be inserted in the message payload
	Payload struct {
		Content struct {
			// Description: Exchange name
			Exchange ExchangeSchema `json:"exchange"`

			// Description: Indicates if the backtest has reached the end date
			Finished bool `json:"finished"`

			// Description: Pair symbol
			Pair PairSchema `json:"pair"`

			// Description: Tick price
			Price float64 `json:"price"`

			// Description: Date-Time format according to RFC3339
			Time DateSchema `json:"time"`
		} `json:"content"`

		// Description: Date-Time format according to RFC3339
		Time DateSchema `json:"time"`

		// Description: Content type of this event
		Type string `json:"type"`
	}
}

func NewBacktestsEventMessage() BacktestsEventMessage {
	var msg BacktestsEventMessage

	return msg
}

// newBacktestsEventMessageFromBrokerMessage will fill a new BacktestsEventMessage with data from generic broker message
func newBacktestsEventMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsEventMessage, error) {
	var msg BacktestsEventMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsEventMessage data
func (msg BacktestsEventMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CreateBacktestOrderRequestMessage is the message expected for 'CreateBacktestOrderRequest' channel
type CreateBacktestOrderRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		Id BacktestIDSchema `json:"id"`

		// Description: Order sent to the market
		Order OrderSchema `json:"order"`
	}
}

func NewCreateBacktestOrderRequestMessage() CreateBacktestOrderRequestMessage {
	var msg CreateBacktestOrderRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newCreateBacktestOrderRequestMessageFromBrokerMessage will fill a new CreateBacktestOrderRequestMessage with data from generic broker message
func newCreateBacktestOrderRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (CreateBacktestOrderRequestMessage, error) {
	var msg CreateBacktestOrderRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from CreateBacktestOrderRequestMessage data
func (msg CreateBacktestOrderRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg CreateBacktestOrderRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *CreateBacktestOrderRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *CreateBacktestOrderRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// CreateBacktestOrderResponseMessage is the message expected for 'CreateBacktestOrderResponse' channel
type CreateBacktestOrderResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewCreateBacktestOrderResponseMessage() CreateBacktestOrderResponseMessage {
	var msg CreateBacktestOrderResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newCreateBacktestOrderResponseMessageFromBrokerMessage will fill a new CreateBacktestOrderResponseMessage with data from generic broker message
func newCreateBacktestOrderResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (CreateBacktestOrderResponseMessage, error) {
	var msg CreateBacktestOrderResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from CreateBacktestOrderResponseMessage data
func (msg CreateBacktestOrderResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg CreateBacktestOrderResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *CreateBacktestOrderResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *CreateBacktestOrderResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// CreateBacktestRequestMessage is the message expected for 'CreateBacktestRequest' channel
type CreateBacktestRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		Accounts []AccountSchema `json:"accounts"`

		// Description: Date-Time format according to RFC3339
		EndTime *DateSchema `json:"end_time"`

		// Description: Period symbol
		Period *PeriodSchema `json:"period"`

		// Description: Date-Time format according to RFC3339
		StartTime DateSchema `json:"start_time"`
	}
}

func NewCreateBacktestRequestMessage() CreateBacktestRequestMessage {
	var msg CreateBacktestRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newCreateBacktestRequestMessageFromBrokerMessage will fill a new CreateBacktestRequestMessage with data from generic broker message
func newCreateBacktestRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (CreateBacktestRequestMessage, error) {
	var msg CreateBacktestRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from CreateBacktestRequestMessage data
func (msg CreateBacktestRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg CreateBacktestRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *CreateBacktestRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *CreateBacktestRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// CreateBacktestResponseMessage is the message expected for 'CreateBacktestResponse' channel
type CreateBacktestResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`

		// Description: Newly created backtest ID
		Id int64 `json:"id"`
	}
}

func NewCreateBacktestResponseMessage() CreateBacktestResponseMessage {
	var msg CreateBacktestResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newCreateBacktestResponseMessageFromBrokerMessage will fill a new CreateBacktestResponseMessage with data from generic broker message
func newCreateBacktestResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (CreateBacktestResponseMessage, error) {
	var msg CreateBacktestResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from CreateBacktestResponseMessage data
func (msg CreateBacktestResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg CreateBacktestResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *CreateBacktestResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *CreateBacktestResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// ListBacktestAccountsRequestMessage is the message expected for 'ListBacktestAccountsRequest' channel
type ListBacktestAccountsRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		Id BacktestIDSchema `json:"id"`
	}
}

func NewListBacktestAccountsRequestMessage() ListBacktestAccountsRequestMessage {
	var msg ListBacktestAccountsRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newListBacktestAccountsRequestMessageFromBrokerMessage will fill a new ListBacktestAccountsRequestMessage with data from generic broker message
func newListBacktestAccountsRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (ListBacktestAccountsRequestMessage, error) {
	var msg ListBacktestAccountsRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ListBacktestAccountsRequestMessage data
func (msg ListBacktestAccountsRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ListBacktestAccountsRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ListBacktestAccountsRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ListBacktestAccountsRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// ListBacktestAccountsResponseMessage is the message expected for 'ListBacktestAccountsResponse' channel
type ListBacktestAccountsResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		Accounts []AccountSchema `json:"accounts"`

		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewListBacktestAccountsResponseMessage() ListBacktestAccountsResponseMessage {
	var msg ListBacktestAccountsResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newListBacktestAccountsResponseMessageFromBrokerMessage will fill a new ListBacktestAccountsResponseMessage with data from generic broker message
func newListBacktestAccountsResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (ListBacktestAccountsResponseMessage, error) {
	var msg ListBacktestAccountsResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ListBacktestAccountsResponseMessage data
func (msg ListBacktestAccountsResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ListBacktestAccountsResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ListBacktestAccountsResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ListBacktestAccountsResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// ListBacktestOrdersRequestMessage is the message expected for 'ListBacktestOrdersRequest' channel
type ListBacktestOrdersRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		Id BacktestIDSchema `json:"id"`
	}
}

func NewListBacktestOrdersRequestMessage() ListBacktestOrdersRequestMessage {
	var msg ListBacktestOrdersRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newListBacktestOrdersRequestMessageFromBrokerMessage will fill a new ListBacktestOrdersRequestMessage with data from generic broker message
func newListBacktestOrdersRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (ListBacktestOrdersRequestMessage, error) {
	var msg ListBacktestOrdersRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ListBacktestOrdersRequestMessage data
func (msg ListBacktestOrdersRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ListBacktestOrdersRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ListBacktestOrdersRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ListBacktestOrdersRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// ListBacktestOrdersResponseMessage is the message expected for 'ListBacktestOrdersResponse' channel
type ListBacktestOrdersResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error  *ErrorSchema  `json:"error"`
		Orders []OrderSchema `json:"orders"`
	}
}

func NewListBacktestOrdersResponseMessage() ListBacktestOrdersResponseMessage {
	var msg ListBacktestOrdersResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newListBacktestOrdersResponseMessageFromBrokerMessage will fill a new ListBacktestOrdersResponseMessage with data from generic broker message
func newListBacktestOrdersResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (ListBacktestOrdersResponseMessage, error) {
	var msg ListBacktestOrdersResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ListBacktestOrdersResponseMessage data
func (msg ListBacktestOrdersResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ListBacktestOrdersResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ListBacktestOrdersResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ListBacktestOrdersResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// ServiceInfoRequestMessage is the message expected for 'ServiceInfoRequest' channel
type ServiceInfoRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct{}
}

func NewServiceInfoRequestMessage() ServiceInfoRequestMessage {
	var msg ServiceInfoRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newServiceInfoRequestMessageFromBrokerMessage will fill a new ServiceInfoRequestMessage with data from generic broker message
func newServiceInfoRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (ServiceInfoRequestMessage, error) {
	var msg ServiceInfoRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ServiceInfoRequestMessage data
func (msg ServiceInfoRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ServiceInfoRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ServiceInfoRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ServiceInfoRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// ServiceInfoResponseMessage is the message expected for 'ServiceInfoResponse' channel
type ServiceInfoResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Version of the API
		ApiVersion string `json:"api_version"`

		// Description: Version of the binary
		BinVersion string `json:"bin_version"`
	}
}

func NewServiceInfoResponseMessage() ServiceInfoResponseMessage {
	var msg ServiceInfoResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newServiceInfoResponseMessageFromBrokerMessage will fill a new ServiceInfoResponseMessage with data from generic broker message
func newServiceInfoResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (ServiceInfoResponseMessage, error) {
	var msg ServiceInfoResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ServiceInfoResponseMessage data
func (msg ServiceInfoResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ServiceInfoResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ServiceInfoResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ServiceInfoResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// SubscribeBacktestRequestMessage is the message expected for 'SubscribeBacktestRequest' channel
type SubscribeBacktestRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Exchange name
		Exchange ExchangeSchema `json:"exchange"`

		// Description: Targeted backtest ID
		Id BacktestIDSchema `json:"id"`

		// Description: Pair symbol
		Pair PairSchema `json:"pair"`
	}
}

func NewSubscribeBacktestRequestMessage() SubscribeBacktestRequestMessage {
	var msg SubscribeBacktestRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newSubscribeBacktestRequestMessageFromBrokerMessage will fill a new SubscribeBacktestRequestMessage with data from generic broker message
func newSubscribeBacktestRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (SubscribeBacktestRequestMessage, error) {
	var msg SubscribeBacktestRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from SubscribeBacktestRequestMessage data
func (msg SubscribeBacktestRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg SubscribeBacktestRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *SubscribeBacktestRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *SubscribeBacktestRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// SubscribeBacktestResponseMessage is the message expected for 'SubscribeBacktestResponse' channel
type SubscribeBacktestResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationId *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewSubscribeBacktestResponseMessage() SubscribeBacktestResponseMessage {
	var msg SubscribeBacktestResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// newSubscribeBacktestResponseMessageFromBrokerMessage will fill a new SubscribeBacktestResponseMessage with data from generic broker message
func newSubscribeBacktestResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (SubscribeBacktestResponseMessage, error) {
	var msg SubscribeBacktestResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from SubscribeBacktestResponseMessage data
func (msg SubscribeBacktestResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg SubscribeBacktestResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *SubscribeBacktestResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *SubscribeBacktestResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// AccountSchema is a schema from the AsyncAPI specification required in messages
type AccountSchema struct {
	// Description: Account's assets
	Assets []AssetSchema `json:"assets"`

	// Description: Account's name
	Name string `json:"name"`
}

// AssetSchema is a schema from the AsyncAPI specification required in messages
// Description: An asset is a particular commodity with an amount
type AssetSchema struct {
	Amount float64 `json:"amount"`
	Name   string  `json:"name"`
}

// BacktestIDSchema is a schema from the AsyncAPI specification required in messages
// Description: Targeted backtest ID
type BacktestIDSchema int64

// DateSchema is a schema from the AsyncAPI specification required in messages
// Description: Date-Time format according to RFC3339
type DateSchema time.Time

// MarshalJSON will override the marshal as this is not a normal 'time.Time' type
func (t DateSchema) MarshalJSON() ([]byte, error) {
	return json.Marshal(time.Time(t))
}

// UnmarshalJSON will override the unmarshal as this is not a normal 'time.Time' type
func (t *DateSchema) UnmarshalJSON(data []byte) error {
	var timeFormat time.Time
	if err := json.Unmarshal(data, &timeFormat); err != nil {
		return err
	}

	*t = DateSchema(timeFormat)
	return nil
}

// ErrorSchema is a schema from the AsyncAPI specification required in messages
// Description: Response to a failed call
type ErrorSchema struct {
	// Description: Code to identify the error type, based on HTTP errors
	Code int64 `json:"code"`

	// Description: Main error reason
	Message string `json:"message"`
}

// ExchangeSchema is a schema from the AsyncAPI specification required in messages
// Description: Exchange name
type ExchangeSchema string

// OrderSchema is a schema from the AsyncAPI specification required in messages
// Description: Order sent to the market
type OrderSchema struct {
	// Description: Exchange name
	Exchange ExchangeSchema `json:"exchange"`

	// Description: Effective time of order execution
	ExecutionTime *DateSchema `json:"execution_time"`

	// Description: Order ID set by the system
	Id *int64 `json:"id"`

	// Description: Pair symbol
	Pair PairSchema `json:"pair"`

	// Description: Price of the asset that where it should be traded
	Price *float64 `json:"price"`

	// Description: Quantity of the asset that should be traded
	Quantity float64 `json:"quantity"`

	// Description: Side used by an order
	Side OrderSideSchema `json:"side"`

	// Description: Type of an order
	Type OrderTypeSchema `json:"type"`
}

// OrderSideSchema is a schema from the AsyncAPI specification required in messages
// Description: Side used by an order
type OrderSideSchema string

// OrderTypeSchema is a schema from the AsyncAPI specification required in messages
// Description: Type of an order
type OrderTypeSchema string

// PairSchema is a schema from the AsyncAPI specification required in messages
// Description: Pair symbol
type PairSchema string

// PeriodSchema is a schema from the AsyncAPI specification required in messages
// Description: Period symbol
type PeriodSchema string

// StatusSchema is a schema from the AsyncAPI specification required in messages
// Description: Status event is happening when there is no more expected events.
// An 'advance' message can be sent after this one.
type StatusSchema struct {
	// Description: Indicates if the backtest has reached the end date
	Finished bool `json:"finished"`
}

// TickSchema is a schema from the AsyncAPI specification required in messages
type TickSchema struct {
	// Description: Exchange name
	Exchange ExchangeSchema `json:"exchange"`

	// Description: Pair symbol
	Pair PairSchema `json:"pair"`

	// Description: Tick price
	Price float64 `json:"price"`

	// Description: Date-Time format according to RFC3339
	Time DateSchema `json:"time"`
}
