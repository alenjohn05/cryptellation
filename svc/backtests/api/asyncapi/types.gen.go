// Package "asyncapi" provides primitives to interact with the AsyncAPI specification.
//
// Code generated by github.com/lerenn/asyncapi-codegen version v0.39.0 DO NOT EDIT.
package asyncapi

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/lerenn/asyncapi-codegen/pkg/extensions"

	"github.com/google/uuid"
)

// AsyncAPIVersion is the version of the used AsyncAPI document
const AsyncAPIVersion = "1.0.0"

// controller is the controller that will be used to communicate with the broker
// It will be used internally by AppController and UserController
type controller struct {
	// broker is the broker controller that will be used to communicate
	broker extensions.BrokerController
	// subscriptions is a map of all subscriptions
	subscriptions map[string]extensions.BrokerChannelSubscription
	// logger is the logger that will be usedÂ² to log operations on controller
	logger extensions.Logger
	// middlewares are the middlewares that will be executed when sending or
	// receiving messages
	middlewares []extensions.Middleware
	// handler to handle errors from consumers and middlewares
	errorHandler extensions.ErrorHandler
}

// ControllerOption is the type of the options that can be passed
// when creating a new Controller
type ControllerOption func(controller *controller)

// WithLogger attaches a logger to the controller
func WithLogger(logger extensions.Logger) ControllerOption {
	return func(controller *controller) {
		controller.logger = logger
	}
}

// WithMiddlewares attaches middlewares that will be executed when sending or receiving messages
func WithMiddlewares(middlewares ...extensions.Middleware) ControllerOption {
	return func(controller *controller) {
		controller.middlewares = middlewares
	}
}

// WithErrorHandler attaches a errorhandler to handle errors from subscriber functions
func WithErrorHandler(handler extensions.ErrorHandler) ControllerOption {
	return func(controller *controller) {
		controller.errorHandler = handler
	}
}

type MessageWithCorrelationID interface {
	CorrelationID() string
	SetCorrelationID(id string)
}

type Error struct {
	Channel string
	Err     error
}

func (e *Error) Error() string {
	return fmt.Sprintf("channel %q: err %v", e.Channel, e.Err)
}

// Message 'AccountsListRequestMessageFromAccountsListRequestChannel' reference another one at '#/components/messages/AccountsListRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'AccountsListResponseMessageFromAccountsListResponseChannel' reference another one at '#/components/messages/AccountsListResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'AdvanceRequestMessageFromAdvanceRequestChannel' reference another one at '#/components/messages/AdvanceRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'AdvanceResponseMessageFromAdvanceResponseChannel' reference another one at '#/components/messages/AdvanceResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'CreateRequestMessageFromCreateRequestChannel' reference another one at '#/components/messages/CreateRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'CreateResponseMessageFromCreateResponseChannel' reference another one at '#/components/messages/CreateResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// EventsChannelParameters represents EventsChannel channel parameters
type EventsChannelParameters struct {
	// Id is a channel parameter: Backtest identifier
	Id string
}

// Message 'EventMessageFromEventsChannel' reference another one at '#/components/messages/Event'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'OrdersCreateRequestMessageFromOrdersCreateRequestChannel' reference another one at '#/components/messages/OrdersCreateRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'OrdersCreateResponseMessageFromOrdersCreateResponseChannel' reference another one at '#/components/messages/OrdersCreateResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'OrdersListRequestMessageFromOrdersListRequestChannel' reference another one at '#/components/messages/OrdersListRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'OrdersListResponseMessageFromOrdersListResponseChannel' reference another one at '#/components/messages/OrdersListResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'ServiceInfoRequestMessageFromServiceInfoRequestChannel' reference another one at '#/components/messages/ServiceInfoRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'ServiceInfoResponseMessageFromServiceInfoResponseChannel' reference another one at '#/components/messages/ServiceInfoResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'SubscribeRequestMessageFromSubscribeRequestChannel' reference another one at '#/components/messages/SubscribeRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'SubscribeResponseMessageFromSubscribeResponseChannel' reference another one at '#/components/messages/SubscribeResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// HeadersFromAccountsListRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromAccountsListRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// AccountsListRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type AccountsListRequestMessagePayload struct {
	// Description: Targeted backtest ID
	Id BacktestIDSchema `json:"id"`
}

// AccountsListRequestMessage is the message expected for 'AccountsListRequestMessage' channel.
type AccountsListRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromAccountsListRequestMessage

	// Payload will be inserted in the message payload
	Payload AccountsListRequestMessagePayload
}

func NewAccountsListRequestMessage() AccountsListRequestMessage {
	var msg AccountsListRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToAccountsListRequestMessage will fill a new AccountsListRequestMessage with data from generic broker message
func brokerMessageToAccountsListRequestMessage(bMsg extensions.BrokerMessage) (AccountsListRequestMessage, error) {
	var msg AccountsListRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AccountsListRequestMessage data
func (msg AccountsListRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg AccountsListRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *AccountsListRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *AccountsListRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromAccountsListResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromAccountsListResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// AccountsListResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type AccountsListResponseMessagePayload struct {
	Accounts []AccountSchema `json:"accounts"`

	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`
}

// AccountsListResponseMessage is the message expected for 'AccountsListResponseMessage' channel.
type AccountsListResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromAccountsListResponseMessage

	// Payload will be inserted in the message payload
	Payload AccountsListResponseMessagePayload
}

func NewAccountsListResponseMessage() AccountsListResponseMessage {
	var msg AccountsListResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToAccountsListResponseMessage will fill a new AccountsListResponseMessage with data from generic broker message
func brokerMessageToAccountsListResponseMessage(bMsg extensions.BrokerMessage) (AccountsListResponseMessage, error) {
	var msg AccountsListResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AccountsListResponseMessage data
func (msg AccountsListResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg AccountsListResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *AccountsListResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *AccountsListResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromAdvanceRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromAdvanceRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// AdvanceRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type AdvanceRequestMessagePayload struct {
	// Description: Targeted backtest ID
	Id BacktestIDSchema `json:"id"`
}

// AdvanceRequestMessage is the message expected for 'AdvanceRequestMessage' channel.
type AdvanceRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromAdvanceRequestMessage

	// Payload will be inserted in the message payload
	Payload AdvanceRequestMessagePayload
}

func NewAdvanceRequestMessage() AdvanceRequestMessage {
	var msg AdvanceRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToAdvanceRequestMessage will fill a new AdvanceRequestMessage with data from generic broker message
func brokerMessageToAdvanceRequestMessage(bMsg extensions.BrokerMessage) (AdvanceRequestMessage, error) {
	var msg AdvanceRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AdvanceRequestMessage data
func (msg AdvanceRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg AdvanceRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *AdvanceRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *AdvanceRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromAdvanceResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromAdvanceResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// AdvanceResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type AdvanceResponseMessagePayload struct {
	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`
}

// AdvanceResponseMessage is the message expected for 'AdvanceResponseMessage' channel.
type AdvanceResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromAdvanceResponseMessage

	// Payload will be inserted in the message payload
	Payload AdvanceResponseMessagePayload
}

func NewAdvanceResponseMessage() AdvanceResponseMessage {
	var msg AdvanceResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToAdvanceResponseMessage will fill a new AdvanceResponseMessage with data from generic broker message
func brokerMessageToAdvanceResponseMessage(bMsg extensions.BrokerMessage) (AdvanceResponseMessage, error) {
	var msg AdvanceResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AdvanceResponseMessage data
func (msg AdvanceResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg AdvanceResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *AdvanceResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *AdvanceResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromCreateRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromCreateRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// CreateRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type CreateRequestMessagePayload struct {
	Accounts []AccountSchema `json:"accounts"`

	// Description: Date-Time format according to RFC3339
	EndTime *DateSchema `json:"end_time"`

	// Description: Period symbol
	Period *PeriodSchema `json:"period"`

	// Description: Date-Time format according to RFC3339
	StartTime DateSchema `json:"start_time"`
}

// CreateRequestMessage is the message expected for 'CreateRequestMessage' channel.
type CreateRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromCreateRequestMessage

	// Payload will be inserted in the message payload
	Payload CreateRequestMessagePayload
}

func NewCreateRequestMessage() CreateRequestMessage {
	var msg CreateRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToCreateRequestMessage will fill a new CreateRequestMessage with data from generic broker message
func brokerMessageToCreateRequestMessage(bMsg extensions.BrokerMessage) (CreateRequestMessage, error) {
	var msg CreateRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from CreateRequestMessage data
func (msg CreateRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg CreateRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *CreateRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *CreateRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromCreateResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromCreateResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// CreateResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type CreateResponseMessagePayload struct {
	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`

	// Description: Newly created backtest ID
	Id string `json:"id"`
}

// CreateResponseMessage is the message expected for 'CreateResponseMessage' channel.
type CreateResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromCreateResponseMessage

	// Payload will be inserted in the message payload
	Payload CreateResponseMessagePayload
}

func NewCreateResponseMessage() CreateResponseMessage {
	var msg CreateResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToCreateResponseMessage will fill a new CreateResponseMessage with data from generic broker message
func brokerMessageToCreateResponseMessage(bMsg extensions.BrokerMessage) (CreateResponseMessage, error) {
	var msg CreateResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from CreateResponseMessage data
func (msg CreateResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg CreateResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *CreateResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *CreateResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// EventMessagePayload is a schema from the AsyncAPI specification required in messages
type EventMessagePayload struct {
	Content ContentPropertyFromEventMessagePayload `json:"content"`

	// Description: Date-Time format according to RFC3339
	Time DateSchema `json:"time"`

	// Description: Content type of this event
	Type string `json:"type"`
}

// ContentPropertyFromEventMessagePayload is a schema from the AsyncAPI specification required in messages
type ContentPropertyFromEventMessagePayload struct {
	// Description: Exchange name
	Exchange ExchangeSchema `json:"exchange"`

	// Description: Indicates if the backtest has reached the end date
	Finished bool `json:"finished"`

	// Description: Pair symbol
	Pair PairSchema `json:"pair"`

	// Description: Tick price
	Price float64 `json:"price"`

	// Description: Date-Time format according to RFC3339
	Time DateSchema `json:"time"`
}

// EventMessage is the message expected for 'EventMessage' channel.
type EventMessage struct {
	// Payload will be inserted in the message payload
	Payload EventMessagePayload
}

func NewEventMessage() EventMessage {
	var msg EventMessage

	return msg
}

// brokerMessageToEventMessage will fill a new EventMessage with data from generic broker message
func brokerMessageToEventMessage(bMsg extensions.BrokerMessage) (EventMessage, error) {
	var msg EventMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from EventMessage data
func (msg EventMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// HeadersFromOrdersCreateRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromOrdersCreateRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// OrdersCreateRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type OrdersCreateRequestMessagePayload struct {
	// Description: Targeted backtest ID
	Id BacktestIDSchema `json:"id"`

	// Description: Order sent to the market
	Order OrderSchema `json:"order"`
}

// OrdersCreateRequestMessage is the message expected for 'OrdersCreateRequestMessage' channel.
type OrdersCreateRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromOrdersCreateRequestMessage

	// Payload will be inserted in the message payload
	Payload OrdersCreateRequestMessagePayload
}

func NewOrdersCreateRequestMessage() OrdersCreateRequestMessage {
	var msg OrdersCreateRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToOrdersCreateRequestMessage will fill a new OrdersCreateRequestMessage with data from generic broker message
func brokerMessageToOrdersCreateRequestMessage(bMsg extensions.BrokerMessage) (OrdersCreateRequestMessage, error) {
	var msg OrdersCreateRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from OrdersCreateRequestMessage data
func (msg OrdersCreateRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg OrdersCreateRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *OrdersCreateRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *OrdersCreateRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromOrdersCreateResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromOrdersCreateResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// OrdersCreateResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type OrdersCreateResponseMessagePayload struct {
	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`
}

// OrdersCreateResponseMessage is the message expected for 'OrdersCreateResponseMessage' channel.
type OrdersCreateResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromOrdersCreateResponseMessage

	// Payload will be inserted in the message payload
	Payload OrdersCreateResponseMessagePayload
}

func NewOrdersCreateResponseMessage() OrdersCreateResponseMessage {
	var msg OrdersCreateResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToOrdersCreateResponseMessage will fill a new OrdersCreateResponseMessage with data from generic broker message
func brokerMessageToOrdersCreateResponseMessage(bMsg extensions.BrokerMessage) (OrdersCreateResponseMessage, error) {
	var msg OrdersCreateResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from OrdersCreateResponseMessage data
func (msg OrdersCreateResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg OrdersCreateResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *OrdersCreateResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *OrdersCreateResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromOrdersListRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromOrdersListRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// OrdersListRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type OrdersListRequestMessagePayload struct {
	// Description: Targeted backtest ID
	Id BacktestIDSchema `json:"id"`
}

// OrdersListRequestMessage is the message expected for 'OrdersListRequestMessage' channel.
type OrdersListRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromOrdersListRequestMessage

	// Payload will be inserted in the message payload
	Payload OrdersListRequestMessagePayload
}

func NewOrdersListRequestMessage() OrdersListRequestMessage {
	var msg OrdersListRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToOrdersListRequestMessage will fill a new OrdersListRequestMessage with data from generic broker message
func brokerMessageToOrdersListRequestMessage(bMsg extensions.BrokerMessage) (OrdersListRequestMessage, error) {
	var msg OrdersListRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from OrdersListRequestMessage data
func (msg OrdersListRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg OrdersListRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *OrdersListRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *OrdersListRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromOrdersListResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromOrdersListResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// OrdersListResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type OrdersListResponseMessagePayload struct {
	// Description: Response to a failed call
	Error  *ErrorSchema  `json:"error"`
	Orders []OrderSchema `json:"orders"`
}

// OrdersListResponseMessage is the message expected for 'OrdersListResponseMessage' channel.
type OrdersListResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromOrdersListResponseMessage

	// Payload will be inserted in the message payload
	Payload OrdersListResponseMessagePayload
}

func NewOrdersListResponseMessage() OrdersListResponseMessage {
	var msg OrdersListResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToOrdersListResponseMessage will fill a new OrdersListResponseMessage with data from generic broker message
func brokerMessageToOrdersListResponseMessage(bMsg extensions.BrokerMessage) (OrdersListResponseMessage, error) {
	var msg OrdersListResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from OrdersListResponseMessage data
func (msg OrdersListResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg OrdersListResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *OrdersListResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *OrdersListResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromServiceInfoRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromServiceInfoRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// ServiceInfoRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type ServiceInfoRequestMessagePayload struct{}

// ServiceInfoRequestMessage is the message expected for 'ServiceInfoRequestMessage' channel.
type ServiceInfoRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromServiceInfoRequestMessage

	// Payload will be inserted in the message payload
	Payload ServiceInfoRequestMessagePayload
}

func NewServiceInfoRequestMessage() ServiceInfoRequestMessage {
	var msg ServiceInfoRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToServiceInfoRequestMessage will fill a new ServiceInfoRequestMessage with data from generic broker message
func brokerMessageToServiceInfoRequestMessage(bMsg extensions.BrokerMessage) (ServiceInfoRequestMessage, error) {
	var msg ServiceInfoRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ServiceInfoRequestMessage data
func (msg ServiceInfoRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ServiceInfoRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ServiceInfoRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ServiceInfoRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromServiceInfoResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromServiceInfoResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// ServiceInfoResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type ServiceInfoResponseMessagePayload struct {
	// Description: Version of the API
	ApiVersion string `json:"apiVersion"`

	// Description: Version of the binary
	BinVersion string `json:"binVersion"`
}

// ServiceInfoResponseMessage is the message expected for 'ServiceInfoResponseMessage' channel.
type ServiceInfoResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromServiceInfoResponseMessage

	// Payload will be inserted in the message payload
	Payload ServiceInfoResponseMessagePayload
}

func NewServiceInfoResponseMessage() ServiceInfoResponseMessage {
	var msg ServiceInfoResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToServiceInfoResponseMessage will fill a new ServiceInfoResponseMessage with data from generic broker message
func brokerMessageToServiceInfoResponseMessage(bMsg extensions.BrokerMessage) (ServiceInfoResponseMessage, error) {
	var msg ServiceInfoResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ServiceInfoResponseMessage data
func (msg ServiceInfoResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ServiceInfoResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ServiceInfoResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ServiceInfoResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromSubscribeRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromSubscribeRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// SubscribeRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type SubscribeRequestMessagePayload struct {
	// Description: Exchange name
	Exchange ExchangeSchema `json:"exchange"`

	// Description: Targeted backtest ID
	Id BacktestIDSchema `json:"id"`

	// Description: Pair symbol
	Pair PairSchema `json:"pair"`
}

// SubscribeRequestMessage is the message expected for 'SubscribeRequestMessage' channel.
type SubscribeRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromSubscribeRequestMessage

	// Payload will be inserted in the message payload
	Payload SubscribeRequestMessagePayload
}

func NewSubscribeRequestMessage() SubscribeRequestMessage {
	var msg SubscribeRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToSubscribeRequestMessage will fill a new SubscribeRequestMessage with data from generic broker message
func brokerMessageToSubscribeRequestMessage(bMsg extensions.BrokerMessage) (SubscribeRequestMessage, error) {
	var msg SubscribeRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from SubscribeRequestMessage data
func (msg SubscribeRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg SubscribeRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *SubscribeRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *SubscribeRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromSubscribeResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromSubscribeResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// SubscribeResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type SubscribeResponseMessagePayload struct {
	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`
}

// SubscribeResponseMessage is the message expected for 'SubscribeResponseMessage' channel.
type SubscribeResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromSubscribeResponseMessage

	// Payload will be inserted in the message payload
	Payload SubscribeResponseMessagePayload
}

func NewSubscribeResponseMessage() SubscribeResponseMessage {
	var msg SubscribeResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToSubscribeResponseMessage will fill a new SubscribeResponseMessage with data from generic broker message
func brokerMessageToSubscribeResponseMessage(bMsg extensions.BrokerMessage) (SubscribeResponseMessage, error) {
	var msg SubscribeResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from SubscribeResponseMessage data
func (msg SubscribeResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg SubscribeResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *SubscribeResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *SubscribeResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// AccountSchema is a schema from the AsyncAPI specification required in messages
type AccountSchema struct {
	// Description: Account's assets
	Assets []AssetSchema `json:"assets"`

	// Description: Account's name
	Name string `json:"name"`
}

// AssetSchema is a schema from the AsyncAPI specification required in messages
// Description: An asset is a particular commodity with an amount
type AssetSchema struct {
	Amount float64 `json:"amount"`
	Name   string  `json:"name"`
}

// BacktestIDSchema is a schema from the AsyncAPI specification required in messages
// Description: Targeted backtest ID
type BacktestIDSchema string

// DateSchema is a schema from the AsyncAPI specification required in messages
// Description: Date-Time format according to RFC3339
type DateSchema time.Time

// MarshalJSON will override the marshal as this is not a normal 'time.Time' type
func (t DateSchema) MarshalJSON() ([]byte, error) {
	return json.Marshal(time.Time(t))
}

// UnmarshalJSON will override the unmarshal as this is not a normal 'time.Time' type
func (t *DateSchema) UnmarshalJSON(data []byte) error {
	var timeFormat time.Time
	if err := json.Unmarshal(data, &timeFormat); err != nil {
		return err
	}

	*t = DateSchema(timeFormat)
	return nil
}

// ErrorSchema is a schema from the AsyncAPI specification required in messages
// Description: Response to a failed call
type ErrorSchema struct {
	// Description: Code to identify the error type, based on HTTP errors
	Code int64 `json:"code"`

	// Description: Main error reason
	Message string `json:"message"`
}

// ExchangeSchema is a schema from the AsyncAPI specification required in messages
// Description: Exchange name
type ExchangeSchema string

// OrderSchema is a schema from the AsyncAPI specification required in messages
// Description: Order sent to the market
type OrderSchema struct {
	// Description: Exchange name
	Exchange ExchangeSchema `json:"exchange"`

	// Description: Effective time of order execution
	ExecutionTime *DateSchema `json:"execution_time"`

	// Description: Order ID set by the system
	Id *string `json:"id"`

	// Description: Pair symbol
	Pair PairSchema `json:"pair"`

	// Description: Price of the asset that where it should be traded
	Price *float64 `json:"price"`

	// Description: Quantity of the asset that should be traded
	Quantity float64 `json:"quantity"`

	// Description: Side used by an order
	Side OrderSideSchema `json:"side"`

	// Description: Type of an order
	Type OrderTypeSchema `json:"type"`
}

// OrderSideSchema is a schema from the AsyncAPI specification required in messages
// Description: Side used by an order
type OrderSideSchema string

// OrderTypeSchema is a schema from the AsyncAPI specification required in messages
// Description: Type of an order
type OrderTypeSchema string

// PairSchema is a schema from the AsyncAPI specification required in messages
// Description: Pair symbol
type PairSchema string

// PeriodSchema is a schema from the AsyncAPI specification required in messages
// Description: Period symbol
type PeriodSchema string

// StatusSchema is a schema from the AsyncAPI specification required in messages
// Description: Status event is happening when there is no more expected events.
// An 'advance' message can be sent after this one.
type StatusSchema struct {
	// Description: Indicates if the backtest has reached the end date
	Finished bool `json:"finished"`
}

// TickSchema is a schema from the AsyncAPI specification required in messages
type TickSchema struct {
	// Description: Exchange name
	Exchange ExchangeSchema `json:"exchange"`

	// Description: Pair symbol
	Pair PairSchema `json:"pair"`

	// Description: Tick price
	Price float64 `json:"price"`

	// Description: Date-Time format according to RFC3339
	Time DateSchema `json:"time"`
}

const (
	// AccountsListRequestChannelPath is the constant representing the 'AccountsListRequestChannel' channel path.
	AccountsListRequestChannelPath = "cryptellation.backtests.accounts.list"
	// AccountsListResponseChannelPath is the constant representing the 'AccountsListResponseChannel' channel path.
	AccountsListResponseChannelPath = ""
	// AdvanceRequestChannelPath is the constant representing the 'AdvanceRequestChannel' channel path.
	AdvanceRequestChannelPath = "cryptellation.backtests.advance"
	// AdvanceResponseChannelPath is the constant representing the 'AdvanceResponseChannel' channel path.
	AdvanceResponseChannelPath = ""
	// CreateRequestChannelPath is the constant representing the 'CreateRequestChannel' channel path.
	CreateRequestChannelPath = "cryptellation.backtests.create"
	// CreateResponseChannelPath is the constant representing the 'CreateResponseChannel' channel path.
	CreateResponseChannelPath = ""
	// EventsChannelPath is the constant representing the 'EventsChannel' channel path.
	EventsChannelPath = "cryptellation.backtests.events.{id}"
	// OrdersCreateRequestChannelPath is the constant representing the 'OrdersCreateRequestChannel' channel path.
	OrdersCreateRequestChannelPath = "cryptellation.backtests.orders.create"
	// OrdersCreateResponseChannelPath is the constant representing the 'OrdersCreateResponseChannel' channel path.
	OrdersCreateResponseChannelPath = ""
	// OrdersListRequestChannelPath is the constant representing the 'OrdersListRequestChannel' channel path.
	OrdersListRequestChannelPath = "cryptellation.backtests.orders.list"
	// OrdersListResponseChannelPath is the constant representing the 'OrdersListResponseChannel' channel path.
	OrdersListResponseChannelPath = ""
	// ServiceInfoRequestChannelPath is the constant representing the 'ServiceInfoRequestChannel' channel path.
	ServiceInfoRequestChannelPath = "cryptellation.backtests.info"
	// ServiceInfoResponseChannelPath is the constant representing the 'ServiceInfoResponseChannel' channel path.
	ServiceInfoResponseChannelPath = ""
	// SubscribeRequestChannelPath is the constant representing the 'SubscribeRequestChannel' channel path.
	SubscribeRequestChannelPath = "cryptellation.backtests.subscribe"
	// SubscribeResponseChannelPath is the constant representing the 'SubscribeResponseChannel' channel path.
	SubscribeResponseChannelPath = ""
)

// ChannelsPaths is an array of all channels paths
var ChannelsPaths = []string{
	AccountsListRequestChannelPath,
	AccountsListResponseChannelPath,
	AdvanceRequestChannelPath,
	AdvanceResponseChannelPath,
	CreateRequestChannelPath,
	CreateResponseChannelPath,
	EventsChannelPath,
	OrdersCreateRequestChannelPath,
	OrdersCreateResponseChannelPath,
	OrdersListRequestChannelPath,
	OrdersListResponseChannelPath,
	ServiceInfoRequestChannelPath,
	ServiceInfoResponseChannelPath,
	SubscribeRequestChannelPath,
	SubscribeResponseChannelPath,
}
