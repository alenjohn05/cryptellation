// Package "asyncapi" provides primitives to interact with the AsyncAPI specification.
//
// Code generated by github.com/lerenn/asyncapi-codegen version v0.39.0 DO NOT EDIT.
package asyncapi

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/lerenn/asyncapi-codegen/pkg/extensions"

	"github.com/google/uuid"
)

// AsyncAPIVersion is the version of the used AsyncAPI document
const AsyncAPIVersion = "1.0.0"

// controller is the controller that will be used to communicate with the broker
// It will be used internally by AppController and UserController
type controller struct {
	// broker is the broker controller that will be used to communicate
	broker extensions.BrokerController
	// subscriptions is a map of all subscriptions
	subscriptions map[string]extensions.BrokerChannelSubscription
	// logger is the logger that will be usedÂ² to log operations on controller
	logger extensions.Logger
	// middlewares are the middlewares that will be executed when sending or
	// receiving messages
	middlewares []extensions.Middleware
	// handler to handle errors from consumers and middlewares
	errorHandler extensions.ErrorHandler
}

// ControllerOption is the type of the options that can be passed
// when creating a new Controller
type ControllerOption func(controller *controller)

// WithLogger attaches a logger to the controller
func WithLogger(logger extensions.Logger) ControllerOption {
	return func(controller *controller) {
		controller.logger = logger
	}
}

// WithMiddlewares attaches middlewares that will be executed when sending or receiving messages
func WithMiddlewares(middlewares ...extensions.Middleware) ControllerOption {
	return func(controller *controller) {
		controller.middlewares = middlewares
	}
}

// WithErrorHandler attaches a errorhandler to handle errors from subscriber functions
func WithErrorHandler(handler extensions.ErrorHandler) ControllerOption {
	return func(controller *controller) {
		controller.errorHandler = handler
	}
}

type MessageWithCorrelationID interface {
	CorrelationID() string
	SetCorrelationID(id string)
}

type Error struct {
	Channel string
	Err     error
}

func (e *Error) Error() string {
	return fmt.Sprintf("channel %q: err %v", e.Channel, e.Err)
}

// Message 'AccountsListRequestMessageFromAccountsListRequestChannel' reference another one at '#/components/messages/AccountsListRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'AccountsListResponseMessageFromAccountsListResponseChannel' reference another one at '#/components/messages/AccountsListResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'CreateRequestMessageFromCreateRequestChannel' reference another one at '#/components/messages/CreateRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'CreateResponseMessageFromCreateResponseChannel' reference another one at '#/components/messages/CreateResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'ListRequestMessageFromListRequestChannel' reference another one at '#/components/messages/ListRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'ListResponseMessageFromListResponseChannel' reference another one at '#/components/messages/ListResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'OrdersCreateRequestMessageFromOrdersCreateRequestChannel' reference another one at '#/components/messages/OrdersCreateRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'OrdersCreateResponseMessageFromOrdersCreateResponseChannel' reference another one at '#/components/messages/OrdersCreateResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'ServiceInfoRequestMessageFromServiceInfoRequestChannel' reference another one at '#/components/messages/ServiceInfoRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'ServiceInfoResponseMessageFromServiceInfoResponseChannel' reference another one at '#/components/messages/ServiceInfoResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'StatusRequestMessageFromStatusRequestChannel' reference another one at '#/components/messages/StatusRequest'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// Message 'StatusResponseMessageFromStatusResponseChannel' reference another one at '#/components/messages/StatusResponse'.
// This should be fixed in a future version to allow message override.
// If you encounter this message, feel free to open an issue on this subject
// to let know that you need this functionnality.

// HeadersFromAccountsListRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromAccountsListRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// AccountsListRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type AccountsListRequestMessagePayload struct {
	// Description: Targeted forwardtest ID
	Id ForwardTestIDSchema `json:"id"`
}

// AccountsListRequestMessage is the message expected for 'AccountsListRequestMessage' channel.
type AccountsListRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromAccountsListRequestMessage

	// Payload will be inserted in the message payload
	Payload AccountsListRequestMessagePayload
}

func NewAccountsListRequestMessage() AccountsListRequestMessage {
	var msg AccountsListRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToAccountsListRequestMessage will fill a new AccountsListRequestMessage with data from generic broker message
func brokerMessageToAccountsListRequestMessage(bMsg extensions.BrokerMessage) (AccountsListRequestMessage, error) {
	var msg AccountsListRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AccountsListRequestMessage data
func (msg AccountsListRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg AccountsListRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *AccountsListRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *AccountsListRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromAccountsListResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromAccountsListResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// AccountsListResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type AccountsListResponseMessagePayload struct {
	Accounts []AccountSchema `json:"accounts"`

	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`
}

// AccountsListResponseMessage is the message expected for 'AccountsListResponseMessage' channel.
type AccountsListResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromAccountsListResponseMessage

	// Payload will be inserted in the message payload
	Payload AccountsListResponseMessagePayload
}

func NewAccountsListResponseMessage() AccountsListResponseMessage {
	var msg AccountsListResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToAccountsListResponseMessage will fill a new AccountsListResponseMessage with data from generic broker message
func brokerMessageToAccountsListResponseMessage(bMsg extensions.BrokerMessage) (AccountsListResponseMessage, error) {
	var msg AccountsListResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from AccountsListResponseMessage data
func (msg AccountsListResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg AccountsListResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *AccountsListResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *AccountsListResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromCreateRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromCreateRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// CreateRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type CreateRequestMessagePayload struct {
	Accounts []AccountSchema `json:"accounts"`
}

// CreateRequestMessage is the message expected for 'CreateRequestMessage' channel.
type CreateRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromCreateRequestMessage

	// Payload will be inserted in the message payload
	Payload CreateRequestMessagePayload
}

func NewCreateRequestMessage() CreateRequestMessage {
	var msg CreateRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToCreateRequestMessage will fill a new CreateRequestMessage with data from generic broker message
func brokerMessageToCreateRequestMessage(bMsg extensions.BrokerMessage) (CreateRequestMessage, error) {
	var msg CreateRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from CreateRequestMessage data
func (msg CreateRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg CreateRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *CreateRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *CreateRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromCreateResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromCreateResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// CreateResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type CreateResponseMessagePayload struct {
	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`

	// Description: Newly created forwardtest ID
	Id string `json:"id"`
}

// CreateResponseMessage is the message expected for 'CreateResponseMessage' channel.
type CreateResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromCreateResponseMessage

	// Payload will be inserted in the message payload
	Payload CreateResponseMessagePayload
}

func NewCreateResponseMessage() CreateResponseMessage {
	var msg CreateResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToCreateResponseMessage will fill a new CreateResponseMessage with data from generic broker message
func brokerMessageToCreateResponseMessage(bMsg extensions.BrokerMessage) (CreateResponseMessage, error) {
	var msg CreateResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from CreateResponseMessage data
func (msg CreateResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg CreateResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *CreateResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *CreateResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromListRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromListRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// ListRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type ListRequestMessagePayload struct{}

// ListRequestMessage is the message expected for 'ListRequestMessage' channel.
type ListRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromListRequestMessage

	// Payload will be inserted in the message payload
	Payload ListRequestMessagePayload
}

func NewListRequestMessage() ListRequestMessage {
	var msg ListRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToListRequestMessage will fill a new ListRequestMessage with data from generic broker message
func brokerMessageToListRequestMessage(bMsg extensions.BrokerMessage) (ListRequestMessage, error) {
	var msg ListRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ListRequestMessage data
func (msg ListRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ListRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ListRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ListRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromListResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromListResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// ListResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type ListResponseMessagePayload struct {
	// Description: Response to a failed call
	Error        *ErrorSchema        `json:"error"`
	Forwardtests []ForwardTestSchema `json:"forwardtests"`
}

// ListResponseMessage is the message expected for 'ListResponseMessage' channel.
type ListResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromListResponseMessage

	// Payload will be inserted in the message payload
	Payload ListResponseMessagePayload
}

func NewListResponseMessage() ListResponseMessage {
	var msg ListResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToListResponseMessage will fill a new ListResponseMessage with data from generic broker message
func brokerMessageToListResponseMessage(bMsg extensions.BrokerMessage) (ListResponseMessage, error) {
	var msg ListResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ListResponseMessage data
func (msg ListResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ListResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ListResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ListResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromOrdersCreateRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromOrdersCreateRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// OrdersCreateRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type OrdersCreateRequestMessagePayload struct {
	// Description: Targeted forwardtest ID
	Id ForwardTestIDSchema `json:"id"`

	// Description: Order sent to the market
	Order OrderSchema `json:"order"`
}

// OrdersCreateRequestMessage is the message expected for 'OrdersCreateRequestMessage' channel.
type OrdersCreateRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromOrdersCreateRequestMessage

	// Payload will be inserted in the message payload
	Payload OrdersCreateRequestMessagePayload
}

func NewOrdersCreateRequestMessage() OrdersCreateRequestMessage {
	var msg OrdersCreateRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToOrdersCreateRequestMessage will fill a new OrdersCreateRequestMessage with data from generic broker message
func brokerMessageToOrdersCreateRequestMessage(bMsg extensions.BrokerMessage) (OrdersCreateRequestMessage, error) {
	var msg OrdersCreateRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from OrdersCreateRequestMessage data
func (msg OrdersCreateRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg OrdersCreateRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *OrdersCreateRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *OrdersCreateRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromOrdersCreateResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromOrdersCreateResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// OrdersCreateResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type OrdersCreateResponseMessagePayload struct {
	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`
}

// OrdersCreateResponseMessage is the message expected for 'OrdersCreateResponseMessage' channel.
type OrdersCreateResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromOrdersCreateResponseMessage

	// Payload will be inserted in the message payload
	Payload OrdersCreateResponseMessagePayload
}

func NewOrdersCreateResponseMessage() OrdersCreateResponseMessage {
	var msg OrdersCreateResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToOrdersCreateResponseMessage will fill a new OrdersCreateResponseMessage with data from generic broker message
func brokerMessageToOrdersCreateResponseMessage(bMsg extensions.BrokerMessage) (OrdersCreateResponseMessage, error) {
	var msg OrdersCreateResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from OrdersCreateResponseMessage data
func (msg OrdersCreateResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg OrdersCreateResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *OrdersCreateResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *OrdersCreateResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromServiceInfoRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromServiceInfoRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// ServiceInfoRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type ServiceInfoRequestMessagePayload struct{}

// ServiceInfoRequestMessage is the message expected for 'ServiceInfoRequestMessage' channel.
type ServiceInfoRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromServiceInfoRequestMessage

	// Payload will be inserted in the message payload
	Payload ServiceInfoRequestMessagePayload
}

func NewServiceInfoRequestMessage() ServiceInfoRequestMessage {
	var msg ServiceInfoRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToServiceInfoRequestMessage will fill a new ServiceInfoRequestMessage with data from generic broker message
func brokerMessageToServiceInfoRequestMessage(bMsg extensions.BrokerMessage) (ServiceInfoRequestMessage, error) {
	var msg ServiceInfoRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ServiceInfoRequestMessage data
func (msg ServiceInfoRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ServiceInfoRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ServiceInfoRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ServiceInfoRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromServiceInfoResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromServiceInfoResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// ServiceInfoResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type ServiceInfoResponseMessagePayload struct {
	// Description: Version of the API
	ApiVersion string `json:"apiVersion"`

	// Description: Version of the binary
	BinVersion string `json:"binVersion"`
}

// ServiceInfoResponseMessage is the message expected for 'ServiceInfoResponseMessage' channel.
type ServiceInfoResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromServiceInfoResponseMessage

	// Payload will be inserted in the message payload
	Payload ServiceInfoResponseMessagePayload
}

func NewServiceInfoResponseMessage() ServiceInfoResponseMessage {
	var msg ServiceInfoResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToServiceInfoResponseMessage will fill a new ServiceInfoResponseMessage with data from generic broker message
func brokerMessageToServiceInfoResponseMessage(bMsg extensions.BrokerMessage) (ServiceInfoResponseMessage, error) {
	var msg ServiceInfoResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from ServiceInfoResponseMessage data
func (msg ServiceInfoResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg ServiceInfoResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *ServiceInfoResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *ServiceInfoResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromStatusRequestMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromStatusRequestMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`

	// Description: Channel used to respond to request
	ReplyTo string `json:"replyTo"`
}

// StatusRequestMessagePayload is a schema from the AsyncAPI specification required in messages
type StatusRequestMessagePayload struct {
	// Description: Targeted forwardtest ID
	Id ForwardTestIDSchema `json:"id"`
}

// StatusRequestMessage is the message expected for 'StatusRequestMessage' channel.
type StatusRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromStatusRequestMessage

	// Payload will be inserted in the message payload
	Payload StatusRequestMessagePayload
}

func NewStatusRequestMessage() StatusRequestMessage {
	var msg StatusRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToStatusRequestMessage will fill a new StatusRequestMessage with data from generic broker message
func brokerMessageToStatusRequestMessage(bMsg extensions.BrokerMessage) (StatusRequestMessage, error) {
	var msg StatusRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		case k == "replyTo": // Retrieving ReplyTo header
			msg.Headers.ReplyTo = string(v)
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from StatusRequestMessage data
func (msg StatusRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 2)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	} // Adding ReplyTo header
	headers["replyTo"] = []byte(msg.Headers.ReplyTo)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg StatusRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *StatusRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *StatusRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// HeadersFromStatusResponseMessage is a schema from the AsyncAPI specification required in messages
type HeadersFromStatusResponseMessage struct {
	// Description: Correlation ID set by client
	CorrelationId *string `json:"correlationId"`
}

// StatusResponseMessagePayload is a schema from the AsyncAPI specification required in messages
type StatusResponseMessagePayload struct {
	// Description: Response to a failed call
	Error *ErrorSchema `json:"error"`

	// Description: Status of a forwardtest
	Status *ForwardTestStatusSchema `json:"status"`
}

// StatusResponseMessage is the message expected for 'StatusResponseMessage' channel.
type StatusResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers HeadersFromStatusResponseMessage

	// Payload will be inserted in the message payload
	Payload StatusResponseMessagePayload
}

func NewStatusResponseMessage() StatusResponseMessage {
	var msg StatusResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationId = &u

	return msg
}

// brokerMessageToStatusResponseMessage will fill a new StatusResponseMessage with data from generic broker message
func brokerMessageToStatusResponseMessage(bMsg extensions.BrokerMessage) (StatusResponseMessage, error) {
	var msg StatusResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationId header
			h := string(v)
			msg.Headers.CorrelationId = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from StatusResponseMessage data
func (msg StatusResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationId header
	if msg.Headers.CorrelationId != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationId)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg StatusResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationId != nil {
		return *msg.Headers.CorrelationId
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *StatusResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationId = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *StatusResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationId = &id
}

// AccountSchema is a schema from the AsyncAPI specification required in messages
type AccountSchema struct {
	// Description: Account's assets
	Assets []AssetSchema `json:"assets"`

	// Description: Account's name
	Name string `json:"name"`
}

// AssetSchema is a schema from the AsyncAPI specification required in messages
// Description: An asset is a particular commodity with an amount
type AssetSchema struct {
	Amount float64 `json:"amount"`
	Name   string  `json:"name"`
}

// DateSchema is a schema from the AsyncAPI specification required in messages
// Description: Date-Time format according to RFC3339
type DateSchema time.Time

// MarshalJSON will override the marshal as this is not a normal 'time.Time' type
func (t DateSchema) MarshalJSON() ([]byte, error) {
	return json.Marshal(time.Time(t))
}

// UnmarshalJSON will override the unmarshal as this is not a normal 'time.Time' type
func (t *DateSchema) UnmarshalJSON(data []byte) error {
	var timeFormat time.Time
	if err := json.Unmarshal(data, &timeFormat); err != nil {
		return err
	}

	*t = DateSchema(timeFormat)
	return nil
}

// ErrorSchema is a schema from the AsyncAPI specification required in messages
// Description: Response to a failed call
type ErrorSchema struct {
	// Description: Code to identify the error type, based on HTTP errors
	Code int64 `json:"code"`

	// Description: Main error reason
	Message string `json:"message"`
}

// ExchangeSchema is a schema from the AsyncAPI specification required in messages
// Description: Exchange name
type ExchangeSchema string

// ForwardTestSchema is a schema from the AsyncAPI specification required in messages
type ForwardTestSchema struct {
	// Description: Targeted forwardtest ID
	Id ForwardTestIDSchema `json:"id"`

	// Description: Date-Time format according to RFC3339
	UpdatedAt DateSchema `json:"updated_at"`
}

// ForwardTestIDSchema is a schema from the AsyncAPI specification required in messages
// Description: Targeted forwardtest ID
type ForwardTestIDSchema string

// ForwardTestStatusSchema is a schema from the AsyncAPI specification required in messages
// Description: Status of a forwardtest
type ForwardTestStatusSchema struct {
	// Description: Current balance of the forwardtest
	Balance float64 `json:"balance"`
}

// OrderSchema is a schema from the AsyncAPI specification required in messages
// Description: Order sent to the market
type OrderSchema struct {
	// Description: Exchange name
	Exchange ExchangeSchema `json:"exchange"`

	// Description: Effective time of order execution
	ExecutionTime *DateSchema `json:"execution_time"`

	// Description: Order ID set by the system
	Id *string `json:"id"`

	// Description: Pair symbol
	Pair PairSchema `json:"pair"`

	// Description: Price of the asset that where it should be traded
	Price *float64 `json:"price"`

	// Description: Quantity of the asset that should be traded
	Quantity float64 `json:"quantity"`

	// Description: Side used by an order
	Side OrderSideSchema `json:"side"`

	// Description: Type of an order
	Type OrderTypeSchema `json:"type"`
}

// OrderSideSchema is a schema from the AsyncAPI specification required in messages
// Description: Side used by an order
type OrderSideSchema string

// OrderTypeSchema is a schema from the AsyncAPI specification required in messages
// Description: Type of an order
type OrderTypeSchema string

// PairSchema is a schema from the AsyncAPI specification required in messages
// Description: Pair symbol
type PairSchema string

// PeriodSchema is a schema from the AsyncAPI specification required in messages
// Description: Period symbol
type PeriodSchema string

const (
	// AccountsListRequestChannelPath is the constant representing the 'AccountsListRequestChannel' channel path.
	AccountsListRequestChannelPath = "cryptellation.forwardtests.accounts.list"
	// AccountsListResponseChannelPath is the constant representing the 'AccountsListResponseChannel' channel path.
	AccountsListResponseChannelPath = ""
	// CreateRequestChannelPath is the constant representing the 'CreateRequestChannel' channel path.
	CreateRequestChannelPath = "cryptellation.forwardtests.create"
	// CreateResponseChannelPath is the constant representing the 'CreateResponseChannel' channel path.
	CreateResponseChannelPath = ""
	// ListRequestChannelPath is the constant representing the 'ListRequestChannel' channel path.
	ListRequestChannelPath = "cryptellation.forwardtests.list"
	// ListResponseChannelPath is the constant representing the 'ListResponseChannel' channel path.
	ListResponseChannelPath = ""
	// OrdersCreateRequestChannelPath is the constant representing the 'OrdersCreateRequestChannel' channel path.
	OrdersCreateRequestChannelPath = "cryptellation.forwardtests.orders.create"
	// OrdersCreateResponseChannelPath is the constant representing the 'OrdersCreateResponseChannel' channel path.
	OrdersCreateResponseChannelPath = ""
	// ServiceInfoRequestChannelPath is the constant representing the 'ServiceInfoRequestChannel' channel path.
	ServiceInfoRequestChannelPath = "cryptellation.forwardtests.info"
	// ServiceInfoResponseChannelPath is the constant representing the 'ServiceInfoResponseChannel' channel path.
	ServiceInfoResponseChannelPath = ""
	// StatusRequestChannelPath is the constant representing the 'StatusRequestChannel' channel path.
	StatusRequestChannelPath = "cryptellation.forwardtests.status"
	// StatusResponseChannelPath is the constant representing the 'StatusResponseChannel' channel path.
	StatusResponseChannelPath = ""
)

// ChannelsPaths is an array of all channels paths
var ChannelsPaths = []string{
	AccountsListRequestChannelPath,
	AccountsListResponseChannelPath,
	CreateRequestChannelPath,
	CreateResponseChannelPath,
	ListRequestChannelPath,
	ListResponseChannelPath,
	OrdersCreateRequestChannelPath,
	OrdersCreateResponseChannelPath,
	ServiceInfoRequestChannelPath,
	ServiceInfoResponseChannelPath,
	StatusRequestChannelPath,
	StatusResponseChannelPath,
}
