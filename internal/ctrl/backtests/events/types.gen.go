// Package "events" provides primitives to interact with the AsyncAPI specification.
//
// Code generated by github.com/lerenn/asyncapi-codegen version v0.13.1 DO NOT EDIT.
package events

import (
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
)

var (
	// Generic error for AsyncAPI generated code
	ErrAsyncAPI = errors.New("error when using AsyncAPI")

	// ErrContextCanceled is given when a given context is canceled
	ErrContextCanceled = fmt.Errorf("%w: context canceled", ErrAsyncAPI)

	// ErrNilBrokerController is raised when a nil broker controller is user
	ErrNilBrokerController = fmt.Errorf("%w: nil broker controller has been used", ErrAsyncAPI)

	// ErrNilAppSubscriber is raised when a nil app subscriber is user
	ErrNilAppSubscriber = fmt.Errorf("%w: nil app subscriber has been used", ErrAsyncAPI)

	// ErrNilClientSubscriber is raised when a nil client subscriber is user
	ErrNilClientSubscriber = fmt.Errorf("%w: nil client subscriber has been used", ErrAsyncAPI)

	// ErrAlreadySubscribedChannel is raised when a subscription is done twice
	// or more without unsubscribing
	ErrAlreadySubscribedChannel = fmt.Errorf("%w: the channel has already been subscribed", ErrAsyncAPI)

	// ErrSubscriptionCanceled is raised when expecting something and the subscription has been canceled before it happens
	ErrSubscriptionCanceled = fmt.Errorf("%w: the subscription has been canceled", ErrAsyncAPI)
)

type Logger interface {
	// Info logs information based on a message and key-value elements
	Info(msg string, keyvals ...interface{})

	// Error logs error based on a message and key-value elements
	Error(msg string, keyvals ...interface{})
}

type MessageWithCorrelationID interface {
	CorrelationID() string
}

type Error struct {
	Channel string
	Err     error
}

func (e *Error) Error() string {
	return fmt.Sprintf("channel %q: err %v", e.Channel, e.Err)
}

// CryptellationBacktestsEventsIDParameters represents CryptellationBacktestsEventsID channel parameters
type CryptellationBacktestsEventsIDParameters struct {
	// Description: Backtest identifier
	ID int64
}

// BacktestsAccountsListRequestMessage is the message expected for 'BacktestsAccountsListRequest' channel
type BacktestsAccountsListRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`
	}
}

func NewBacktestsAccountsListRequestMessage() BacktestsAccountsListRequestMessage {
	var msg BacktestsAccountsListRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsAccountsListRequestMessageFromUniversalMessage will fill a new BacktestsAccountsListRequestMessage with data from UniversalMessage
func newBacktestsAccountsListRequestMessageFromUniversalMessage(um UniversalMessage) (BacktestsAccountsListRequestMessage, error) {
	var msg BacktestsAccountsListRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsAccountsListRequestMessage data
func (msg BacktestsAccountsListRequestMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsAccountsListRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsAccountsListRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsAccountsListResponseMessage is the message expected for 'BacktestsAccountsListResponse' channel
type BacktestsAccountsListResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		Accounts []AccountSchema `json:"accounts"`

		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewBacktestsAccountsListResponseMessage() BacktestsAccountsListResponseMessage {
	var msg BacktestsAccountsListResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsAccountsListResponseMessageFromUniversalMessage will fill a new BacktestsAccountsListResponseMessage with data from UniversalMessage
func newBacktestsAccountsListResponseMessageFromUniversalMessage(um UniversalMessage) (BacktestsAccountsListResponseMessage, error) {
	var msg BacktestsAccountsListResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsAccountsListResponseMessage data
func (msg BacktestsAccountsListResponseMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsAccountsListResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsAccountsListResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsAdvanceRequestMessage is the message expected for 'BacktestsAdvanceRequest' channel
type BacktestsAdvanceRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`
	}
}

func NewBacktestsAdvanceRequestMessage() BacktestsAdvanceRequestMessage {
	var msg BacktestsAdvanceRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsAdvanceRequestMessageFromUniversalMessage will fill a new BacktestsAdvanceRequestMessage with data from UniversalMessage
func newBacktestsAdvanceRequestMessageFromUniversalMessage(um UniversalMessage) (BacktestsAdvanceRequestMessage, error) {
	var msg BacktestsAdvanceRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsAdvanceRequestMessage data
func (msg BacktestsAdvanceRequestMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsAdvanceRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsAdvanceRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsAdvanceResponseMessage is the message expected for 'BacktestsAdvanceResponse' channel
type BacktestsAdvanceResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewBacktestsAdvanceResponseMessage() BacktestsAdvanceResponseMessage {
	var msg BacktestsAdvanceResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsAdvanceResponseMessageFromUniversalMessage will fill a new BacktestsAdvanceResponseMessage with data from UniversalMessage
func newBacktestsAdvanceResponseMessageFromUniversalMessage(um UniversalMessage) (BacktestsAdvanceResponseMessage, error) {
	var msg BacktestsAdvanceResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsAdvanceResponseMessage data
func (msg BacktestsAdvanceResponseMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsAdvanceResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsAdvanceResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsCreateRequestMessage is the message expected for 'BacktestsCreateRequest' channel
type BacktestsCreateRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		Accounts []AccountSchema `json:"accounts"`

		// Description: Date-Time format according to RFC3339
		EndTime *DateSchema `json:"end_time"`

		// Description: Period symbol
		Period *PeriodSymbolSchema `json:"period"`

		// Description: Date-Time format according to RFC3339
		StartTime DateSchema `json:"start_time"`
	}
}

func NewBacktestsCreateRequestMessage() BacktestsCreateRequestMessage {
	var msg BacktestsCreateRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsCreateRequestMessageFromUniversalMessage will fill a new BacktestsCreateRequestMessage with data from UniversalMessage
func newBacktestsCreateRequestMessageFromUniversalMessage(um UniversalMessage) (BacktestsCreateRequestMessage, error) {
	var msg BacktestsCreateRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsCreateRequestMessage data
func (msg BacktestsCreateRequestMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsCreateRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsCreateRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsCreateResponseMessage is the message expected for 'BacktestsCreateResponse' channel
type BacktestsCreateResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`

		// Description: Newly created backtest ID
		ID int64 `json:"id"`
	}
}

func NewBacktestsCreateResponseMessage() BacktestsCreateResponseMessage {
	var msg BacktestsCreateResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsCreateResponseMessageFromUniversalMessage will fill a new BacktestsCreateResponseMessage with data from UniversalMessage
func newBacktestsCreateResponseMessageFromUniversalMessage(um UniversalMessage) (BacktestsCreateResponseMessage, error) {
	var msg BacktestsCreateResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsCreateResponseMessage data
func (msg BacktestsCreateResponseMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsCreateResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsCreateResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsEventMessage is the message expected for 'BacktestsEvent' channel
type BacktestsEventMessage struct {
	// Payload will be inserted in the message payload
	Payload struct {
		Content struct {
			// Description: Exchange name
			Exchange ExchangeNameSchema `json:"exchange"`

			// Description: Indicates if the backtest has reached the end date
			Finished bool `json:"finished"`

			// Description: Pair symbol
			PairSymbol PairSymbolSchema `json:"pair_symbol"`

			// Description: Tick price
			Price float64 `json:"price"`

			// Description: Date-Time format according to RFC3339
			Time DateSchema `json:"time"`
		} `json:"content"`

		// Description: Date-Time format according to RFC3339
		Time DateSchema `json:"time"`

		// Description: Content type of this event
		Type string `json:"type"`
	}
}

func NewBacktestsEventMessage() BacktestsEventMessage {
	var msg BacktestsEventMessage

	return msg
}

// newBacktestsEventMessageFromUniversalMessage will fill a new BacktestsEventMessage with data from UniversalMessage
func newBacktestsEventMessageFromUniversalMessage(um UniversalMessage) (BacktestsEventMessage, error) {
	var msg BacktestsEventMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsEventMessage data
func (msg BacktestsEventMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	return UniversalMessage{
		Payload: payload,
	}, nil
}

// BacktestsOrdersCreateRequestMessage is the message expected for 'BacktestsOrdersCreateRequest' channel
type BacktestsOrdersCreateRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`

		// Description: Order sent to the market
		Order OrderSchema `json:"order"`
	}
}

func NewBacktestsOrdersCreateRequestMessage() BacktestsOrdersCreateRequestMessage {
	var msg BacktestsOrdersCreateRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsOrdersCreateRequestMessageFromUniversalMessage will fill a new BacktestsOrdersCreateRequestMessage with data from UniversalMessage
func newBacktestsOrdersCreateRequestMessageFromUniversalMessage(um UniversalMessage) (BacktestsOrdersCreateRequestMessage, error) {
	var msg BacktestsOrdersCreateRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsOrdersCreateRequestMessage data
func (msg BacktestsOrdersCreateRequestMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsOrdersCreateRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsOrdersCreateRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsOrdersCreateResponseMessage is the message expected for 'BacktestsOrdersCreateResponse' channel
type BacktestsOrdersCreateResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewBacktestsOrdersCreateResponseMessage() BacktestsOrdersCreateResponseMessage {
	var msg BacktestsOrdersCreateResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsOrdersCreateResponseMessageFromUniversalMessage will fill a new BacktestsOrdersCreateResponseMessage with data from UniversalMessage
func newBacktestsOrdersCreateResponseMessageFromUniversalMessage(um UniversalMessage) (BacktestsOrdersCreateResponseMessage, error) {
	var msg BacktestsOrdersCreateResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsOrdersCreateResponseMessage data
func (msg BacktestsOrdersCreateResponseMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsOrdersCreateResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsOrdersCreateResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsOrdersListRequestMessage is the message expected for 'BacktestsOrdersListRequest' channel
type BacktestsOrdersListRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`
	}
}

func NewBacktestsOrdersListRequestMessage() BacktestsOrdersListRequestMessage {
	var msg BacktestsOrdersListRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsOrdersListRequestMessageFromUniversalMessage will fill a new BacktestsOrdersListRequestMessage with data from UniversalMessage
func newBacktestsOrdersListRequestMessageFromUniversalMessage(um UniversalMessage) (BacktestsOrdersListRequestMessage, error) {
	var msg BacktestsOrdersListRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsOrdersListRequestMessage data
func (msg BacktestsOrdersListRequestMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsOrdersListRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsOrdersListRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsOrdersListResponseMessage is the message expected for 'BacktestsOrdersListResponse' channel
type BacktestsOrdersListResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error  *ErrorSchema  `json:"error"`
		Orders []OrderSchema `json:"orders"`
	}
}

func NewBacktestsOrdersListResponseMessage() BacktestsOrdersListResponseMessage {
	var msg BacktestsOrdersListResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsOrdersListResponseMessageFromUniversalMessage will fill a new BacktestsOrdersListResponseMessage with data from UniversalMessage
func newBacktestsOrdersListResponseMessageFromUniversalMessage(um UniversalMessage) (BacktestsOrdersListResponseMessage, error) {
	var msg BacktestsOrdersListResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsOrdersListResponseMessage data
func (msg BacktestsOrdersListResponseMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsOrdersListResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsOrdersListResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsSubscribeRequestMessage is the message expected for 'BacktestsSubscribeRequest' channel
type BacktestsSubscribeRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Exchange name
		ExchangeName ExchangeNameSchema `json:"exchange_name"`

		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`

		// Description: Pair symbol
		PairSymbol PairSymbolSchema `json:"pair_symbol"`
	}
}

func NewBacktestsSubscribeRequestMessage() BacktestsSubscribeRequestMessage {
	var msg BacktestsSubscribeRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsSubscribeRequestMessageFromUniversalMessage will fill a new BacktestsSubscribeRequestMessage with data from UniversalMessage
func newBacktestsSubscribeRequestMessageFromUniversalMessage(um UniversalMessage) (BacktestsSubscribeRequestMessage, error) {
	var msg BacktestsSubscribeRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsSubscribeRequestMessage data
func (msg BacktestsSubscribeRequestMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsSubscribeRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsSubscribeRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsSubscribeResponseMessage is the message expected for 'BacktestsSubscribeResponse' channel
type BacktestsSubscribeResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewBacktestsSubscribeResponseMessage() BacktestsSubscribeResponseMessage {
	var msg BacktestsSubscribeResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsSubscribeResponseMessageFromUniversalMessage will fill a new BacktestsSubscribeResponseMessage with data from UniversalMessage
func newBacktestsSubscribeResponseMessageFromUniversalMessage(um UniversalMessage) (BacktestsSubscribeResponseMessage, error) {
	var msg BacktestsSubscribeResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(um.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get correlation ID
	msg.Headers.CorrelationID = um.CorrelationID

	// TODO: run checks on msg type

	return msg, nil
}

// toUniversalMessage will generate an UniversalMessage from BacktestsSubscribeResponseMessage data
func (msg BacktestsSubscribeResponseMessage) toUniversalMessage() (UniversalMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return UniversalMessage{}, err
	}

	// Set correlation ID if it does not exist
	var correlationID *string
	if msg.Headers.CorrelationID != nil {
		correlationID = msg.Headers.CorrelationID
	} else {
		u := uuid.New().String()
		correlationID = &u
	}

	return UniversalMessage{
		Payload:       payload,
		CorrelationID: correlationID,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsSubscribeResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsSubscribeResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// AccountSchema is a schema from the AsyncAPI specification required in messages
type AccountSchema struct {
	// Description: Account's assets
	Assets []AssetSchema `json:"assets"`

	// Description: Account's name
	Name string `json:"name"`
}

// AssetSchema is a schema from the AsyncAPI specification required in messages
// Description: An asset is a particular commodity with an amount
type AssetSchema struct {
	Amount float64 `json:"amount"`
	Name   string  `json:"name"`
}

// BacktestIDSchema is a schema from the AsyncAPI specification required in messages
// Description: Targeted backtest ID
type BacktestIDSchema int64

// DateSchema is a schema from the AsyncAPI specification required in messages
// Description: Date-Time format according to RFC3339
type DateSchema time.Time

// MarshalJSON will override the marshal as this is not a normal 'time.Time' type
func (t DateSchema) MarshalJSON() ([]byte, error) {
	return json.Marshal(time.Time(t))
}

// UnmarshalJSON will override the unmarshal as this is not a normal 'time.Time' type
func (t *DateSchema) UnmarshalJSON(data []byte) error {
	var timeFormat time.Time
	if err := json.Unmarshal(data, &timeFormat); err != nil {
		return err
	}

	*t = DateSchema(timeFormat)
	return nil
}

// ErrorSchema is a schema from the AsyncAPI specification required in messages
// Description: Response to a failed call
type ErrorSchema struct {
	// Description: Code to identify the error type, based on HTTP errors
	Code int64 `json:"code"`

	// Description: Main error reason
	Message string `json:"message"`
}

// ExchangeNameSchema is a schema from the AsyncAPI specification required in messages
// Description: Exchange name
type ExchangeNameSchema string

// OrderSchema is a schema from the AsyncAPI specification required in messages
// Description: Order sent to the market
type OrderSchema struct {
	// Description: Exchange name
	ExchangeName ExchangeNameSchema `json:"exchange_name"`

	// Description: Effective time of order execution
	ExecutionTime *DateSchema `json:"execution_time"`

	// Description: Order ID set by the system
	ID *int64 `json:"id"`

	// Description: Pair symbol
	PairSymbol PairSymbolSchema `json:"pair_symbol"`

	// Description: Price of the asset that where it should be traded
	Price *float64 `json:"price"`

	// Description: Quantity of the asset that should be traded
	Quantity float64 `json:"quantity"`

	// Description: Side used by an order
	Side OrderSideSchema `json:"side"`

	// Description: Type of an order
	Type OrderTypeSchema `json:"type"`
}

// OrderSideSchema is a schema from the AsyncAPI specification required in messages
// Description: Side used by an order
type OrderSideSchema string

// OrderTypeSchema is a schema from the AsyncAPI specification required in messages
// Description: Type of an order
type OrderTypeSchema string

// PairSymbolSchema is a schema from the AsyncAPI specification required in messages
// Description: Pair symbol
type PairSymbolSchema string

// PeriodSymbolSchema is a schema from the AsyncAPI specification required in messages
// Description: Period symbol
type PeriodSymbolSchema string

// StatusSchema is a schema from the AsyncAPI specification required in messages
// Description: Status event is happening when there is no more expected events.
// An 'advance' message can be sent after this one.
type StatusSchema struct {
	// Description: Indicates if the backtest has reached the end date
	Finished bool `json:"finished"`
}

// TickSchema is a schema from the AsyncAPI specification required in messages
type TickSchema struct {
	// Description: Exchange name
	Exchange ExchangeNameSchema `json:"exchange"`

	// Description: Pair symbol
	PairSymbol PairSymbolSchema `json:"pair_symbol"`

	// Description: Tick price
	Price float64 `json:"price"`

	// Description: Date-Time format according to RFC3339
	Time DateSchema `json:"time"`
}
