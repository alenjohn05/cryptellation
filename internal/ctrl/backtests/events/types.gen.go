// Package "events" provides primitives to interact with the AsyncAPI specification.
//
// Code generated by github.com/lerenn/asyncapi-codegen version v0.24.3 DO NOT EDIT.
package events

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/lerenn/asyncapi-codegen/pkg/extensions"

	"github.com/google/uuid"
)

// controller is the controller that will be used to communicate with the broker
// It will be used internally by AppController and UserController
type controller struct {
	// broker is the broker controller that will be used to communicate
	broker extensions.BrokerController
	// subscriptions is a map of all subscriptions
	subscriptions map[string]extensions.BrokerChannelSubscription
	// logger is the logger that will be usedÂ² to log operations on controller
	logger extensions.Logger
	// middlewares are the middlewares that will be executed when sending or
	// receiving messages
	middlewares []extensions.Middleware
}

// ControllerOption is the type of the options that can be passed
// when creating a new Controller
type ControllerOption func(controller *controller)

// WithLogger attaches a logger to the controller
func WithLogger(logger extensions.Logger) ControllerOption {
	return func(controller *controller) {
		controller.logger = logger
	}
}

// WithMiddlewares attaches middlewares that will be executed when sending or receiving messages
func WithMiddlewares(middlewares ...extensions.Middleware) ControllerOption {
	return func(controller *controller) {
		controller.middlewares = middlewares
	}
}

type MessageWithCorrelationID interface {
	CorrelationID() string
	SetCorrelationID(id string)
}

type Error struct {
	Channel string
	Err     error
}

func (e *Error) Error() string {
	return fmt.Sprintf("channel %q: err %v", e.Channel, e.Err)
}

// CryptellationBacktestsEventsIDParameters represents CryptellationBacktestsEventsID channel parameters
type CryptellationBacktestsEventsIDParameters struct {
	// Description: Backtest identifier
	ID int64
}

// BacktestsAccountsListRequestMessage is the message expected for 'BacktestsAccountsListRequest' channel
type BacktestsAccountsListRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`
	}
}

func NewBacktestsAccountsListRequestMessage() BacktestsAccountsListRequestMessage {
	var msg BacktestsAccountsListRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsAccountsListRequestMessageFromBrokerMessage will fill a new BacktestsAccountsListRequestMessage with data from generic broker message
func newBacktestsAccountsListRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsAccountsListRequestMessage, error) {
	var msg BacktestsAccountsListRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsAccountsListRequestMessage data
func (msg BacktestsAccountsListRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsAccountsListRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsAccountsListRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsAccountsListRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsAccountsListResponseMessage is the message expected for 'BacktestsAccountsListResponse' channel
type BacktestsAccountsListResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		Accounts []AccountSchema `json:"accounts"`

		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewBacktestsAccountsListResponseMessage() BacktestsAccountsListResponseMessage {
	var msg BacktestsAccountsListResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsAccountsListResponseMessageFromBrokerMessage will fill a new BacktestsAccountsListResponseMessage with data from generic broker message
func newBacktestsAccountsListResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsAccountsListResponseMessage, error) {
	var msg BacktestsAccountsListResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsAccountsListResponseMessage data
func (msg BacktestsAccountsListResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsAccountsListResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsAccountsListResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsAccountsListResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsAdvanceRequestMessage is the message expected for 'BacktestsAdvanceRequest' channel
type BacktestsAdvanceRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`
	}
}

func NewBacktestsAdvanceRequestMessage() BacktestsAdvanceRequestMessage {
	var msg BacktestsAdvanceRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsAdvanceRequestMessageFromBrokerMessage will fill a new BacktestsAdvanceRequestMessage with data from generic broker message
func newBacktestsAdvanceRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsAdvanceRequestMessage, error) {
	var msg BacktestsAdvanceRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsAdvanceRequestMessage data
func (msg BacktestsAdvanceRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsAdvanceRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsAdvanceRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsAdvanceRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsAdvanceResponseMessage is the message expected for 'BacktestsAdvanceResponse' channel
type BacktestsAdvanceResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewBacktestsAdvanceResponseMessage() BacktestsAdvanceResponseMessage {
	var msg BacktestsAdvanceResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsAdvanceResponseMessageFromBrokerMessage will fill a new BacktestsAdvanceResponseMessage with data from generic broker message
func newBacktestsAdvanceResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsAdvanceResponseMessage, error) {
	var msg BacktestsAdvanceResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsAdvanceResponseMessage data
func (msg BacktestsAdvanceResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsAdvanceResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsAdvanceResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsAdvanceResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsCreateRequestMessage is the message expected for 'BacktestsCreateRequest' channel
type BacktestsCreateRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		Accounts []AccountSchema `json:"accounts"`

		// Description: Date-Time format according to RFC3339
		EndTime *DateSchema `json:"end_time"`

		// Description: Period symbol
		Period *PeriodSymbolSchema `json:"period"`

		// Description: Date-Time format according to RFC3339
		StartTime DateSchema `json:"start_time"`
	}
}

func NewBacktestsCreateRequestMessage() BacktestsCreateRequestMessage {
	var msg BacktestsCreateRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsCreateRequestMessageFromBrokerMessage will fill a new BacktestsCreateRequestMessage with data from generic broker message
func newBacktestsCreateRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsCreateRequestMessage, error) {
	var msg BacktestsCreateRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsCreateRequestMessage data
func (msg BacktestsCreateRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsCreateRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsCreateRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsCreateRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsCreateResponseMessage is the message expected for 'BacktestsCreateResponse' channel
type BacktestsCreateResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`

		// Description: Newly created backtest ID
		ID int64 `json:"id"`
	}
}

func NewBacktestsCreateResponseMessage() BacktestsCreateResponseMessage {
	var msg BacktestsCreateResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsCreateResponseMessageFromBrokerMessage will fill a new BacktestsCreateResponseMessage with data from generic broker message
func newBacktestsCreateResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsCreateResponseMessage, error) {
	var msg BacktestsCreateResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsCreateResponseMessage data
func (msg BacktestsCreateResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsCreateResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsCreateResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsCreateResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsEventMessage is the message expected for 'BacktestsEvent' channel
type BacktestsEventMessage struct {
	// Payload will be inserted in the message payload
	Payload struct {
		Content struct {
			// Description: Exchange name
			Exchange ExchangeNameSchema `json:"exchange"`

			// Description: Indicates if the backtest has reached the end date
			Finished bool `json:"finished"`

			// Description: Pair symbol
			PairSymbol PairSymbolSchema `json:"pair_symbol"`

			// Description: Tick price
			Price float64 `json:"price"`

			// Description: Date-Time format according to RFC3339
			Time DateSchema `json:"time"`
		} `json:"content"`

		// Description: Date-Time format according to RFC3339
		Time DateSchema `json:"time"`

		// Description: Content type of this event
		Type string `json:"type"`
	}
}

func NewBacktestsEventMessage() BacktestsEventMessage {
	var msg BacktestsEventMessage

	return msg
}

// newBacktestsEventMessageFromBrokerMessage will fill a new BacktestsEventMessage with data from generic broker message
func newBacktestsEventMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsEventMessage, error) {
	var msg BacktestsEventMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsEventMessage data
func (msg BacktestsEventMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// There is no headers here
	headers := make(map[string][]byte, 0)

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// BacktestsOrdersCreateRequestMessage is the message expected for 'BacktestsOrdersCreateRequest' channel
type BacktestsOrdersCreateRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`

		// Description: Order sent to the market
		Order OrderSchema `json:"order"`
	}
}

func NewBacktestsOrdersCreateRequestMessage() BacktestsOrdersCreateRequestMessage {
	var msg BacktestsOrdersCreateRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsOrdersCreateRequestMessageFromBrokerMessage will fill a new BacktestsOrdersCreateRequestMessage with data from generic broker message
func newBacktestsOrdersCreateRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsOrdersCreateRequestMessage, error) {
	var msg BacktestsOrdersCreateRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsOrdersCreateRequestMessage data
func (msg BacktestsOrdersCreateRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsOrdersCreateRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsOrdersCreateRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsOrdersCreateRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsOrdersCreateResponseMessage is the message expected for 'BacktestsOrdersCreateResponse' channel
type BacktestsOrdersCreateResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewBacktestsOrdersCreateResponseMessage() BacktestsOrdersCreateResponseMessage {
	var msg BacktestsOrdersCreateResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsOrdersCreateResponseMessageFromBrokerMessage will fill a new BacktestsOrdersCreateResponseMessage with data from generic broker message
func newBacktestsOrdersCreateResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsOrdersCreateResponseMessage, error) {
	var msg BacktestsOrdersCreateResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsOrdersCreateResponseMessage data
func (msg BacktestsOrdersCreateResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsOrdersCreateResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsOrdersCreateResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsOrdersCreateResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsOrdersListRequestMessage is the message expected for 'BacktestsOrdersListRequest' channel
type BacktestsOrdersListRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`
	}
}

func NewBacktestsOrdersListRequestMessage() BacktestsOrdersListRequestMessage {
	var msg BacktestsOrdersListRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsOrdersListRequestMessageFromBrokerMessage will fill a new BacktestsOrdersListRequestMessage with data from generic broker message
func newBacktestsOrdersListRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsOrdersListRequestMessage, error) {
	var msg BacktestsOrdersListRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsOrdersListRequestMessage data
func (msg BacktestsOrdersListRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsOrdersListRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsOrdersListRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsOrdersListRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsOrdersListResponseMessage is the message expected for 'BacktestsOrdersListResponse' channel
type BacktestsOrdersListResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error  *ErrorSchema  `json:"error"`
		Orders []OrderSchema `json:"orders"`
	}
}

func NewBacktestsOrdersListResponseMessage() BacktestsOrdersListResponseMessage {
	var msg BacktestsOrdersListResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsOrdersListResponseMessageFromBrokerMessage will fill a new BacktestsOrdersListResponseMessage with data from generic broker message
func newBacktestsOrdersListResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsOrdersListResponseMessage, error) {
	var msg BacktestsOrdersListResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsOrdersListResponseMessage data
func (msg BacktestsOrdersListResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsOrdersListResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsOrdersListResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsOrdersListResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsSubscribeRequestMessage is the message expected for 'BacktestsSubscribeRequest' channel
type BacktestsSubscribeRequestMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Exchange name
		ExchangeName ExchangeNameSchema `json:"exchange_name"`

		// Description: Targeted backtest ID
		ID BacktestIDSchema `json:"id"`

		// Description: Pair symbol
		PairSymbol PairSymbolSchema `json:"pair_symbol"`
	}
}

func NewBacktestsSubscribeRequestMessage() BacktestsSubscribeRequestMessage {
	var msg BacktestsSubscribeRequestMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsSubscribeRequestMessageFromBrokerMessage will fill a new BacktestsSubscribeRequestMessage with data from generic broker message
func newBacktestsSubscribeRequestMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsSubscribeRequestMessage, error) {
	var msg BacktestsSubscribeRequestMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsSubscribeRequestMessage data
func (msg BacktestsSubscribeRequestMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsSubscribeRequestMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsSubscribeRequestMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsSubscribeRequestMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// BacktestsSubscribeResponseMessage is the message expected for 'BacktestsSubscribeResponse' channel
type BacktestsSubscribeResponseMessage struct {
	// Headers will be used to fill the message headers
	Headers struct {
		// Description: Correlation ID set by client
		CorrelationID *string `json:"correlation_id"`
	}

	// Payload will be inserted in the message payload
	Payload struct {
		// Description: Response to a failed call
		Error *ErrorSchema `json:"error"`
	}
}

func NewBacktestsSubscribeResponseMessage() BacktestsSubscribeResponseMessage {
	var msg BacktestsSubscribeResponseMessage

	// Set correlation ID
	u := uuid.New().String()
	msg.Headers.CorrelationID = &u

	return msg
}

// newBacktestsSubscribeResponseMessageFromBrokerMessage will fill a new BacktestsSubscribeResponseMessage with data from generic broker message
func newBacktestsSubscribeResponseMessageFromBrokerMessage(bMsg extensions.BrokerMessage) (BacktestsSubscribeResponseMessage, error) {
	var msg BacktestsSubscribeResponseMessage

	// Unmarshal payload to expected message payload format
	err := json.Unmarshal(bMsg.Payload, &msg.Payload)
	if err != nil {
		return msg, err
	}

	// Get each headers from broker message
	for k, v := range bMsg.Headers {
		switch {
		case k == "correlationId": // Retrieving CorrelationID header
			h := string(v)
			msg.Headers.CorrelationID = &h
		default:
			// TODO: log unknown error
		}
	}

	// TODO: run checks on msg type

	return msg, nil
}

// toBrokerMessage will generate a generic broker message from BacktestsSubscribeResponseMessage data
func (msg BacktestsSubscribeResponseMessage) toBrokerMessage() (extensions.BrokerMessage, error) {
	// TODO: implement checks on message

	// Marshal payload to JSON
	payload, err := json.Marshal(msg.Payload)
	if err != nil {
		return extensions.BrokerMessage{}, err
	}

	// Add each headers to broker message
	headers := make(map[string][]byte, 1)

	// Adding CorrelationID header
	if msg.Headers.CorrelationID != nil {
		headers["correlationId"] = []byte(*msg.Headers.CorrelationID)
	}

	return extensions.BrokerMessage{
		Headers: headers,
		Payload: payload,
	}, nil
}

// CorrelationID will give the correlation ID of the message, based on AsyncAPI spec
func (msg BacktestsSubscribeResponseMessage) CorrelationID() string {
	if msg.Headers.CorrelationID != nil {
		return *msg.Headers.CorrelationID
	}

	return ""
}

// SetCorrelationID will set the correlation ID of the message, based on AsyncAPI spec
func (msg *BacktestsSubscribeResponseMessage) SetCorrelationID(id string) {
	msg.Headers.CorrelationID = &id
}

// SetAsResponseFrom will correlate the message with the one passed in parameter.
// It will assign the 'req' message correlation ID to the message correlation ID,
// both specified in AsyncAPI spec.
func (msg *BacktestsSubscribeResponseMessage) SetAsResponseFrom(req MessageWithCorrelationID) {
	id := req.CorrelationID()
	msg.Headers.CorrelationID = &id
}

// AccountSchema is a schema from the AsyncAPI specification required in messages
type AccountSchema struct {
	// Description: Account's assets
	Assets []AssetSchema `json:"assets"`

	// Description: Account's name
	Name string `json:"name"`
}

// AssetSchema is a schema from the AsyncAPI specification required in messages
// Description: An asset is a particular commodity with an amount
type AssetSchema struct {
	Amount float64 `json:"amount"`
	Name   string  `json:"name"`
}

// BacktestIDSchema is a schema from the AsyncAPI specification required in messages
// Description: Targeted backtest ID
type BacktestIDSchema int64

// DateSchema is a schema from the AsyncAPI specification required in messages
// Description: Date-Time format according to RFC3339
type DateSchema time.Time

// MarshalJSON will override the marshal as this is not a normal 'time.Time' type
func (t DateSchema) MarshalJSON() ([]byte, error) {
	return json.Marshal(time.Time(t))
}

// UnmarshalJSON will override the unmarshal as this is not a normal 'time.Time' type
func (t *DateSchema) UnmarshalJSON(data []byte) error {
	var timeFormat time.Time
	if err := json.Unmarshal(data, &timeFormat); err != nil {
		return err
	}

	*t = DateSchema(timeFormat)
	return nil
}

// ErrorSchema is a schema from the AsyncAPI specification required in messages
// Description: Response to a failed call
type ErrorSchema struct {
	// Description: Code to identify the error type, based on HTTP errors
	Code int64 `json:"code"`

	// Description: Main error reason
	Message string `json:"message"`
}

// ExchangeNameSchema is a schema from the AsyncAPI specification required in messages
// Description: Exchange name
type ExchangeNameSchema string

// OrderSchema is a schema from the AsyncAPI specification required in messages
// Description: Order sent to the market
type OrderSchema struct {
	// Description: Exchange name
	ExchangeName ExchangeNameSchema `json:"exchange_name"`

	// Description: Effective time of order execution
	ExecutionTime *DateSchema `json:"execution_time"`

	// Description: Order ID set by the system
	ID *int64 `json:"id"`

	// Description: Pair symbol
	PairSymbol PairSymbolSchema `json:"pair_symbol"`

	// Description: Price of the asset that where it should be traded
	Price *float64 `json:"price"`

	// Description: Quantity of the asset that should be traded
	Quantity float64 `json:"quantity"`

	// Description: Side used by an order
	Side OrderSideSchema `json:"side"`

	// Description: Type of an order
	Type OrderTypeSchema `json:"type"`
}

// OrderSideSchema is a schema from the AsyncAPI specification required in messages
// Description: Side used by an order
type OrderSideSchema string

// OrderTypeSchema is a schema from the AsyncAPI specification required in messages
// Description: Type of an order
type OrderTypeSchema string

// PairSymbolSchema is a schema from the AsyncAPI specification required in messages
// Description: Pair symbol
type PairSymbolSchema string

// PeriodSymbolSchema is a schema from the AsyncAPI specification required in messages
// Description: Period symbol
type PeriodSymbolSchema string

// StatusSchema is a schema from the AsyncAPI specification required in messages
// Description: Status event is happening when there is no more expected events.
// An 'advance' message can be sent after this one.
type StatusSchema struct {
	// Description: Indicates if the backtest has reached the end date
	Finished bool `json:"finished"`
}

// TickSchema is a schema from the AsyncAPI specification required in messages
type TickSchema struct {
	// Description: Exchange name
	Exchange ExchangeNameSchema `json:"exchange"`

	// Description: Pair symbol
	PairSymbol PairSymbolSchema `json:"pair_symbol"`

	// Description: Tick price
	Price float64 `json:"price"`

	// Description: Date-Time format according to RFC3339
	Time DateSchema `json:"time"`
}
